<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>panic on Golang island</title>
    <link>https://www.golangi.net/tags/panic/</link>
    <description>Recent content in panic on Golang island</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 05 May 2022 14:36:13 +0800</lastBuildDate><atom:link href="https://www.golangi.net/tags/panic/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The Best Practice of Handling Go Error</title>
      <link>https://www.golangi.net/post/the-best-practice-of-handling-go-error/</link>
      <pubDate>Thu, 05 May 2022 14:36:13 +0800</pubDate>
      
      <guid>https://www.golangi.net/post/the-best-practice-of-handling-go-error/</guid>
      <description>Today we share best practices for error handling in the Golang, learn about the current shortcomings of errors, compromises, and considerations when using them.
 What is error As you know, error is an interface type embedded in the source code. According to the export principle, only uppercase ones can be referenced by other source code packages, but error is predeclared identifiers and is not a keyword.
1 2 3 4 5  // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error.</description>
    </item>
    
  </channel>
</rss>
